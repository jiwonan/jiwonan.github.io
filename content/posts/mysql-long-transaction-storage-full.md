---
title: "MySQL Long Transaction으로 인한 Storage Full 장애 분석"
date: 2026-02-03
draft: false
categories: ["DEV"]
tags: ["MySQL", "InnoDB", "MVCC", "Undo Log", "장애분석"]
description: "Long Transaction으로 인한 Undo Log 누적과 Storage Full 장애의 원인 분석 및 재발 방지 대책"
---

## 1. 장애 개요

### 1.1 현상

- **기간:** 약 2개월간 점진적 진행
- **증상:**
    - HLL(History List Length) 지속적 증가
    - Replica의 Free Storage Space가 Primary보다 빠르게 소진
    - 최종적으로 Storage Full 장애 발생
- **원인 쿼리:** Redash adhoc 쿼리 (수동 실행 쿼리)
- **장애 시점 지표:**
    - 해당 쿼리 AAS (Average Active Session): 0.99~0.98
    - ActiveTransactions: 1.09 ~ 2 유지

        ![ActiveTransactions 지표](/images/mysql-long-transaction/image%201.png)

    - HLL(History List Length): 점진적 증가. 장애 발생 직전 시점에는 128,550,452

        ![HLL 지표](/images/mysql-long-transaction/image%202.png)

        - connections 장애로 위 쿼리가 사라지자 HHL 값이 급격히 낮아짐.

### 1.2 장애 타임라인

```
[T+0]     adhoc 쿼리 실행 시작 (트랜잭션 시작)
[T+0~2M]  쿼리 미종료 또는 반복 실행, HLL 지속 증가
[T+2M]    Replica Storage Full → 장애 발생
[T+2M+]   DB 재시작으로 연결 끊김, 트랜잭션 종료
```

---

## 2. MySQL MVCC (Multi-Version Concurrency Control)

### 2.1 MVCC 란?

MVCC는 동시에 여러 트랜잭션이 같은 데이터에 접근할 때, **Lock 없이 일관된 읽기**를 제공하는 매커니즘이다.

```
┌─────────────────────────────────────────────────────────────┐
│                        MVCC 동작 원리                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Transaction A (시작: T1)     Transaction B (시작: T2)       │
│   SELECT * FROM users         UPDATE users SET name='Kim'   │
│         │                              │                    │
│         ▼                              ▼                    │
│   ┌──────────────┐             ┌──────────────┐             │
│   │ T1 시점의      │             │ 현재 데이터    │             │
│   │ 스냅샷 읽기     │             │ 직접 수정      │             │
│   └──────────────┘             └──────────────┘             │
│         │                              │                    │
│         │                              ▼                    │
│         │                      ┌──────────────┐             │
│         │                      │ 이전 버전을     │             │
│         │                      │ Undo Log에    │             │
│         │◄─────────────────────│ 보관          │             │
│                                └──────────────┘             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 MVCC의 핵심 구성요소

| 구성요소 | 역할 |
| --- | --- |
| **Read View** | 트랜잭션 시작 시점의 "스냅샷" 정보 |
| **Undo Log** | 데이터의 이전 버전들을 저장 |
| **Transaction ID** | 각 트랜잭션의 고유 식별자 |
| **Row Versioning** | 각 행이 어떤 트랜잭션에서 생성/수정되었는지 기록 |

### 2.3 Consistent Read (일관된 읽기)

```sql
-- Transaction A (T1에 시작)
START TRANSACTION;
SELECT * FROM orders WHERE id = 100;  -- 결과: amount = 1000

    -- 이 사이에 Transaction B가 amount를 2000으로 변경하고 COMMIT

SELECT * FROM orders WHERE id = 100;  -- 여전히 결과: amount = 1000
                                       -- T1 시점의 스냅샷을 읽기 때문
COMMIT;
```

**InnoDB는 트랜잭션 시작 시점의 데이터를 보장하기 위해, 이전 버전의 데이터를 Undo Log에 보관해야 한다.**

---

## 3. Undo Log 상세 분석

### 3.1 Undo Log란?

Undo Log는 InnoDB에서 다음 두 가지 목적으로 사용된다:

1. **트랜잭션 롤백:** 트랜잭션 실패 시 원래 상태로 복구
2. **MVCC 지원:** 다른 트랜잭션에게 이전 버전의 데이터 제공

### 3.2 Undo Log 저장 구조

```
┌─────────────────────────────────────────────────────────────┐
│                     InnoDB Storage 구조                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐     ┌─────────────────────────────┐    │
│  │   System        │     │      Undo Tablespace        │    │
│  │   Tablespace    │     │  ┌─────────────────────┐    │    │
│  │                 │     │  │ Undo Log Segment 1  │    │    │
│  │  - Data Dict    │     │  ├─────────────────────┤    │    │
│  │  - Doublewrite  │     │  │ Undo Log Segment 2  │    │    │
│  │  - Undo Logs*   │     │  ├─────────────────────┤    │    │
│  │                 │     │  │ ...                 │    │    │
│  └─────────────────┘     │  ├─────────────────────┤    │    │
│                          │  │ Undo Log Segment N  │    │    │
│                          │  └─────────────────────┘    │    │
│                          └─────────────────────────────┘    │
│                                                             │
│  * MySQL 5.6 이전: System Tablespace에 Undo Log 저장           │
│  * MySQL 5.7+: 별도 Undo Tablespace 분리 가능                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 Undo Log 생성 과정

```sql
-- 초기 상태: users 테이블에 id=1, name='Park' 존재

-- Transaction B 실행
UPDATE users SET name = 'Kim' WHERE id = 1;
```

```
┌────────────────────────────────────────────────────────────────┐
│                      UPDATE 실행 시 동작                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 현재 데이터 읽기                                             │
│     ┌──────────────────────┐                                   │
│     │ id=1, name='Park'    │                                   │
│     └──────────────────────┘                                   │
│                │                                               │
│                ▼                                               │
│  2. Undo Log에 이전 버전 저장                                    │
│     ┌──────────────────────────────────────┐                   │
│     │ Undo Log Record                      │                   │
│     │ - Table: users                       │                   │
│     │ - PK: id=1                           │                   │
│     │ - Old Value: name='Park'             │                   │
│     │ - Trx ID: 12345                      │                   │
│     │ - Rollback Pointer: NULL             │                   │
│     └──────────────────────────────────────┘                   │
│                │                                               │
│                ▼                                               │
│  3. 실제 데이터 수정                                             │
│     ┌──────────────────────────────────────┐                   │
│     │ id=1, name='Kim'                     │                   │
│     │ DB_TRX_ID: 12345 (수정한 트랜잭션)     │                   │
│     │ DB_ROLL_PTR: → Undo Log 위치          │                   │
│     └──────────────────────────────────────┘                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 3.4 Undo Log 체인 (버전 체인)

여러 트랜잭션이 같은 행을 수정하면 Undo Log가 체인으로 연결된다:

```
┌─────────────────────────────────────────────────────────────────┐
│                      Undo Log Version Chain                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  현재 데이터 (Clustered Index)                                     │
│  ┌─────────────────────────────┐                                │
│  │ id=1, name='Choi'           │                                │
│  │ DB_TRX_ID: 300              │                                │
│  │ DB_ROLL_PTR ────────────────┼──┐                             │
│  └─────────────────────────────┘  │                             │
│                                   │                             │
│                                   ▼                             │
│  Undo Log Record (Trx 300)        │                             │
│  ┌─────────────────────────────┐  │                             │
│  │ Old: name='Kim'             │  │                             │
│  │ Trx ID: 200                 │  │                             │
│  │ Roll Ptr ───────────────────┼──┼──┐                          │
│  └─────────────────────────────┘  │  │                          │
│                                      │                          │
│                                      ▼                          │
│  Undo Log Record (Trx 200)           │                          │
│  ┌─────────────────────────────┐     │                          │
│  │ Old: name='Park'            │     │                          │
│  │ Trx ID: 100                 │     │                          │
│  │ Roll Ptr: NULL (최초)        │     │                          │
│  └─────────────────────────────┘     │                          │
│                                                                 │
│  ※ 트랜잭션은 자신의 Read View에 맞는 버전까지 체인을 따라감                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**3.4.1 버전 체인의 핵심 구성요소**

InnoDB의 모든 행(row)에는 사용자 데이터 외에 숨겨진 시스템 컬럼이 존재한다:

| 시스템 컬럼 | **크기** | **역할** |
| --- | --- | --- |
| **DB_TRX_ID** | 6 bytes | 이 행을 마지막으로 수정한 트랜잭션 ID |
| **DB_ROLL_PTR** | 7 bytes | 이전 버전을 가리키는 Undo Log 포인터 (Rollback Pointer) |
| **DB_ROW_ID** | 6 bytes | 자동 생성 행 ID (PK가 없을 경우에만 사용) |

```
┌─────────────────────────────────────────────────────────────────┐
│                    행(Row)의 실제 구조                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Clustered Index에 저장된 실제 행 구조:                           │
│                                                                 │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  ┌──────────────┬──────────────┬──────────────────────────┐│ │
│  │  │ DB_TRX_ID    │ DB_ROLL_PTR  │     User Columns         ││ │
│  │  │ (6 bytes)    │ (7 bytes)    │ (id, name, email, ...)   ││ │
│  │  │              │              │                          ││ │
│  │  │ 수정한 Trx     │ Undo Log     │ 실제 데이터                 ││ │
│  │  │ 의 ID         │ 위치 포인터     │                          ││ │
│  │  └──────────────┴──────────────┴──────────────────────────┘│ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                 │
│  예시:                                                           │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  DB_TRX_ID: 300                                            │ │
│  │  DB_ROLL_PTR: 0x0000150A3F28 → Undo Log Segment 위치        │ │
│  │  id: 1                                                     │ │
│  │  name: 'Choi'                                              │ │
│  │  email: 'choi@example.com'                                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**3.4.2 버전 체인 형성 과정 (단계별 시나리오)**

동일한 행에 대해 여러 트랜잭션이 순차적으로 `UPDATE`를 수행하는 상황:

```
┌─────────────────────────────────────────────────────────────────┐
│              버전 체인 형성 과정 - Step by Step                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [초기 상태] Trx 100에서 INSERT                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Clustered Index:                                               │
│  ┌─────────────────────────────────────┐                        │
│  │ id=1, name='Park'                   │                        │
│  │ DB_TRX_ID: 100                      │                        │
│  │ DB_ROLL_PTR: NULL  ← 최초 INSERT    │                        │
│  └─────────────────────────────────────┘                        │
│                                                                 │
│  Undo Log: (없음 - INSERT Undo는 COMMIT 시 바로 삭제 가능)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  [Step 1] Trx 200에서 UPDATE                                    │
│  ─────────────────────────────────────────────────────────────  │
│  UPDATE users SET name = 'Kim' WHERE id = 1;                    │
│                                                                 │
│  1) 현재 행 읽기 (name='Park')                                   │
│  2) Undo Log에 이전 버전 저장                                    │
│  3) 행 업데이트 + 포인터 연결                                     │
│                                                                 │
│  Clustered Index:                                               │
│  ┌─────────────────────────────────────┐                        │
│  │ id=1, name='Kim'     ← 새 값        │                        │
│  │ DB_TRX_ID: 200       ← 수정한 Trx   │                        │
│  │ DB_ROLL_PTR ─────────┼──────┐       │                        │
│  └─────────────────────────────│───────┘                        │
│                                │                                │
│                                ▼                                │
│  Undo Log Segment:   ┌─────────────────────────────────────┐    │
│                      │ Undo Record #1                      │    │
│                      │ ─────────────────────────────────── │    │
│                      │ Table: users                        │    │
│                      │ PK: id=1                            │    │
│                      │ Old Value: name='Park'   ← 이전 값   │    │
│                      │ Old TRX_ID: 100                     │    │
│                      │ Roll Ptr: NULL           ← 체인 끝   │    │
│                      └─────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  [Step 2] Trx 300에서 UPDATE                                    │
│  ─────────────────────────────────────────────────────────────  │
│  UPDATE users SET name = 'Lee' WHERE id = 1;                    │
│                                                                 │
│  Clustered Index:                                               │
│  ┌─────────────────────────────────────┐                        │
│  │ id=1, name='Lee'     ← 최신 값      │                        │
│  │ DB_TRX_ID: 300                      │                        │
│  │ DB_ROLL_PTR ─────────┼──────┐       │                        │
│  └─────────────────────────────│───────┘                        │
│                                │                                │
│                                ▼                                │
│  Undo Log:   ┌─────────────────────────────────────┐            │
│              │ Undo Record #2 (Trx 300이 생성)      │            │
│              │ ─────────────────────────────────── │            │
│              │ Old Value: name='Kim'               │            │
│              │ Old TRX_ID: 200                     │            │
│              │ Roll Ptr ─────────────┼────┐        │            │
│              └───────────────────────────│────────┘            │
│                                          │                      │
│                                          ▼                      │
│              ┌─────────────────────────────────────┐            │
│              │ Undo Record #1 (기존)                │            │
│              │ ─────────────────────────────────── │            │
│              │ Old Value: name='Park'              │            │
│              │ Old TRX_ID: 100                     │            │
│              │ Roll Ptr: NULL                      │            │
│              └─────────────────────────────────────┘            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  [Step 3] Trx 400에서 UPDATE                                    │
│  ─────────────────────────────────────────────────────────────  │
│  UPDATE users SET name = 'Choi' WHERE id = 1;                   │
│                                                                 │
│  최종 버전 체인:                                                  │
│                                                                 │
│  Clustered Index (현재 데이터)                                   │
│  ┌─────────────────────────────────────┐                        │
│  │ id=1, name='Choi'    ← V4 (최신)    │                        │
│  │ DB_TRX_ID: 400                      │                        │
│  │ DB_ROLL_PTR ─────────────────────┐  │                        │
│  └──────────────────────────────────│──┘                        │
│                                     │                           │
│                                     ▼                           │
│                      ┌─────────────────────────────┐            │
│                      │ Undo #3: name='Lee'  (V3)   │            │
│                      │ Old TRX_ID: 300             │            │
│                      │ Roll Ptr ──────────────┐    │            │
│                      └────────────────────────│────┘            │
│                                               │                 │
│                                               ▼                 │
│                      ┌─────────────────────────────┐            │
│                      │ Undo #2: name='Kim'  (V2)   │            │
│                      │ Old TRX_ID: 200             │            │
│                      │ Roll Ptr ──────────────┐    │            │
│                      └────────────────────────│────┘            │
│                                               │                 │
│                                               ▼                 │
│                      ┌─────────────────────────────┐            │
│                      │ Undo #1: name='Park' (V1)   │            │
│                      │ Old TRX_ID: 100             │            │
│                      │ Roll Ptr: NULL ← 체인 끝     │            │
│                      └─────────────────────────────┘            │
│                                                                 │
│  체인 요약:                                                      │
│  Choi(V4) → Lee(V3) → Kim(V2) → Park(V1) → NULL                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**3.4.3 버전 체인 탐색 (Read View와의 연동)**

트랜잭션이 데이터를 읽을 때, 자신의 Read View에 맞는 버전을 찾기 위해 체인을 탐색한다:

```
┌─────────────────────────────────────────────────────────────────┐
│                   버전 체인 탐색 알고리즘                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시나리오:                                                       │
│  - Trx 150이 T=0.5에 시작 (Trx 100 COMMIT 후, Trx 200 시작 전)   │
│  - Trx 150의 Read View: "Trx ID < 150의 커밋된 변경만 보임"       │
│  - 현재 행: Choi (Trx 400)                                       │
│                                                                 │
│  탐색 과정:                                                      │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [Step 1] 현재 행 확인                                           │
│  ┌─────────────────────────────────────┐                        │
│  │ name='Choi', DB_TRX_ID=400          │                        │
│  │                                     │                        │
│  │ 판단: 400 >= 150? YES               │                        │
│  │       → Read View 생성 후 시작된 Trx │                        │
│  │       → ❌ 안 보임, 이전 버전 탐색    │                        │
│  └─────────────────────────────────────┘                        │
│                     │                                           │
│                     ▼ (DB_ROLL_PTR 따라감)                       │
│                                                                 │
│  [Step 2] Undo Record #3 확인                                   │
│  ┌─────────────────────────────────────┐                        │
│  │ name='Lee', Old TRX_ID=300          │                        │
│  │                                     │                        │
│  │ 판단: 300 >= 150? YES               │                        │
│  │       → ❌ 안 보임, 계속 탐색        │                        │
│  └─────────────────────────────────────┘                        │
│                     │                                           │
│                     ▼                                           │
│                                                                 │
│  [Step 3] Undo Record #2 확인                                   │
│  ┌─────────────────────────────────────┐                        │
│  │ name='Kim', Old TRX_ID=200          │                        │
│  │                                     │                        │
│  │ 판단: 200 >= 150? YES               │                        │
│  │       → ❌ 안 보임, 계속 탐색        │                        │
│  └─────────────────────────────────────┘                        │
│                     │                                           │
│                     ▼                                           │
│                                                                 │
│  [Step 4] Undo Record #1 확인                                   │
│  ┌─────────────────────────────────────┐                        │
│  │ name='Park', Old TRX_ID=100         │                        │
│  │                                     │                        │
│  │ 판단: 100 < 150? YES                │                        │
│  │       Trx 100 커밋됨? YES           │                        │
│  │       → ✅ 보임! 이 버전 반환        │                        │
│  └─────────────────────────────────────┘                        │
│                                                                 │
│  결과: Trx 150은 name='Park'를 읽음                              │
│        (현재 행은 'Choi'이지만, 일관된 스냅샷 읽기 제공)            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**3.4.4 버전 체인의 성능 영향**

```
┌─────────────────────────────────────────────────────────────────┐
│                 버전 체인 길이와 성능의 관계                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  체인 탐색 = 순차 접근 (Linked List Traversal)                    │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  체인 길이 1 (Undo 0개):   O(1)  ← 최적                  │    │
│  │  ┌───┐                                                  │    │
│  │  │ V1│                                                  │    │
│  │  └───┘                                                  │    │
│  │                                                         │    │
│  │  체인 길이 3 (Undo 2개):   O(3)  ← 정상                  │    │
│  │  ┌───┐   ┌───┐   ┌───┐                                  │    │
│  │  │ V3│ → │ V2│ → │ V1│                                  │    │
│  │  └───┘   └───┘   └───┘                                  │    │
│  │                                                         │    │
│  │  체인 길이 100 (Undo 99개): O(100)  ← 성능 저하 시작      │    │
│  │  ┌───┐   ┌───┐         ┌───┐                            │    │
│  │  │V100│→ │V99│→ ... → │ V1│                             │    │
│  │  └───┘   └───┘         └───┘                            │    │
│  │                                                         │    │
│  │  체인 길이 10000+:        O(n)  ← 심각한 성능 문제        │    │
│  │  (Long Transaction으로 인한 Purge 지연 시 발생)           │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

성능 영향 요소:

1. 메모리 접근 패턴
    1. Undo Log는 Buffer Pool에 캐시됨
    2. 체인이 길면 → 더 많은 메모리 페이지 접근
    3. Cache Miss 증가 → Disk I/O 증가

        ![실제 장애 시점 Disk Read 지표](/images/mysql-long-transaction/image%203.png)

        실제 장애 시점 Disk Read 지표

2. CPU 오버헤드
    1. 각 Undo Record마다 가시성 판단 수행
    2. 체인이 길수록 더 많은 비교 연산
3. 쿼리 지연
    1. 단일 행 조회: 밀리초 → 초 단위로 증가 가능
    2. 테이블 스캔: 기하급수적 성능 저하

실제 측정 예시 (Hot Row에 대한 SELECT):

| 체인 길이 | 응답 시간 | 상태 |
| --- | --- | --- |
| 1-10 | < 1ms | 정상 |
| 100-1K | 1-10ms | 약간의 지연 |
| 10K-100K | 10-100ms | 성능 저하 |
| 1M+ | > 1s | 심각한 문제 |

**3.4.5 체인 관리와 Purge의 관계**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Purge와 버전 체인 정리                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  정상 상태 (Purge가 잘 동작):                                     │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  시간 T=0:                                                      │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │ V5│ → │ V4│ → │ V3│ → │ V2│ → │ V1│                         │
│  └───┘   └───┘   └───┘   └───┘   └───┘                         │
│                                                                 │
│  시간 T=1 (V1, V2 Purge):                                       │
│  ┌───┐   ┌───┐   ┌───┐                                          │
│  │ V5│ → │ V4│ → │ V3│ → NULL                                   │
│  └───┘   └───┘   └───┘   (정리됨)                               │
│                                                                 │
│  시간 T=2 (V3 Purge):                                           │
│  ┌───┐   ┌───┐                                                  │
│  │ V5│ → │ V4│ → NULL                                           │
│  └───┘   └───┘                                                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Long Transaction 상태 (Purge 차단):                             │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  T=0: Long Tx 시작 (Read View 생성)                              │
│       │                                                         │
│  T=1: │  다른 Tx들이 계속 UPDATE                                  │
│       │  ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐                  │
│       │  │ V5│ → │ V4│ → │ V3│ → │ V2│ → │ V1│                  │
│       │  └───┘   └───┘   └───┘   └───┘   └───┘                  │
│       │                                                         │
│  T=2: │  더 많은 UPDATE                                          │
│       │  ┌───┐   ┌───┐   ...   ┌───┐   ┌───┐                    │
│       │  │V10│ → │ V9│ → ... → │ V2│ → │ V1│                    │
│       │  └───┘   └───┘         └───┘   └───┘                    │
│       │                                                         │
│       │  ❌ Purge 불가! Long Tx가 V1을 필요로 할 수 있음           │
│       │                                                         │
│  T=N: ▼  체인 길이 = 수만~수백만                                  │
│       ┌───┐   ┌───┐         ┌───┐   ┌───┐                       │
│       │V(N)│→ │...│ → ... → │ V2│ → │ V1│                       │
│       └───┘   └───┘         └───┘   └───┘                       │
│                                                                 │
│       → HLL 폭증, Storage 고갈, 성능 저하                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. Purge 메커니즘

### 4.1 Purge란?

Purge는 **더 이상 필요 없는 Undo Log를 정리**하는 백그라운드 프로세스이다.

### 4.2 Purge 동작 조건

- 해당 트랜잭션이 COMMIT 되어있어야 함.
- 해당 Undo Record를 필요로 하는 Read View가 없어야 함.

```
  ┌──────────────────────────────────────────────────────────────────┐
  │  시간순 흐름                                                      │
  ├──────────────────────────────────────────────────────────────────┤
  │                                                                  │
  │  T=0: Trx 100 시작, SELECT 실행                                   │
  │       → Read View 생성: "나는 T=0 시점의 데이터를 볼 거야"           │
  │       → 이 시점 데이터: name = 'Park'                              │
  │                                                                  │
  │  T=1: Trx 200 실행                                                │
  │       UPDATE users SET name = 'Kim' WHERE id = 1;                │
  │       → Undo Log 200 생성: 이전값 'Park' 저장                      │
  │       → COMMIT                                                   │
  │                                                                  │
  │  T=2: Trx 300 실행                                                │
  │       UPDATE users SET name = 'Choi' WHERE id = 1;               │
  │       → Undo Log 300 생성: 이전값 'Kim' 저장                       │
  │       → COMMIT                                                   │
  │                                                                  │
  │  T=3: Trx 100이 다시 SELECT 실행                                  │
  │       → 현재 DB에는 name = 'Choi'                                 │
  │       → 하지만 Read View는 T=0 시점이므로 'Park'을 봐야 함          │
  │       → Undo Log 체인을 따라가서 'Park' 찾음                       │
  │                                                                  │
  └──────────────────────────────────────────────────────────────────┘

  왜 Purge가 안 되는가?

  현재 DB 상태:  name = 'Choi' (최신)
                     │
                     │ Undo Log 300 (이전값: 'Kim')
                     ▼
                name = 'Kim'
                     │
                     │ Undo Log 200 (이전값: 'Park')
                     ▼
                name = 'Park'  ← Trx 100은 이걸 봐야 함!

  MySQL 입장에서:
  "Trx 100이 아직 안 끝났고, T=0 시점 데이터가 필요할 수 있어.
  그러면 'Park'까지 도달하려면 Undo Log 200, 300이 다 있어야 해.
  그래서 둘 다 지울 수 없어."

  | 구분            | 설명                                                            |
  |-----------------|-----------------------------------------------------------------|
  | Read View       | "내가 볼 수 있는 데이터 범위" 정의                              |
  | Undo Log        | 이전 버전 데이터 저장소                                         |
  | Purge 차단 이유 | Trx 100이 나중에 그 데이터를 읽을 때 옛날 버전이 필요할 수 있음 |
```

### 4.3 Purge Thread의 판단 메커니즘

Purge Thread는 개별 row를 확인하는 것이 아니라, **시스템에서 가장 오래된 Read View**를 기준으로 일괄 판단한다.

**4.3.1 핵심 원리**

```
┌─────────────────────────────────────────────────────────────────┐
│                 Purge Thread의 판단 메커니즘                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Purge Thread가 수행하는 작업:                                    │
│                                                                 │
│  1. 시스템의 모든 활성 Read View 수집                             │
│  2. 그 중 가장 오래된 Read View 찾기 (= oldest read view)        │
│  3. 그 Read View 생성 시점 이전에 커밋된 Undo Log만 삭제          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  활성 Read View 목록:                                    │    │
│  │                                                         │    │
│  │  Read View A: TRX_ID 100 시점에 생성  ← 가장 오래됨       │    │
│  │  Read View B: TRX_ID 500 시점에 생성                     │    │
│  │  Read View C: TRX_ID 800 시점에 생성  ← 가장 최신        │    │
│  │                                                         │    │
│  │  → Purge 기준점 = TRX_ID 100                            │    │
│  │  → TRX_ID < 100인 커밋된 트랜잭션의 Undo만 삭제 가능      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**4.3.2 TRX_ID 기준 일괄 판단**

Purge Thread는 "이 row의 Undo를 누가 읽고 있나?"를 개별적으로 확인하지 않는다. 대신 TRX_ID만 보고 일괄 판단한다:

```
┌─────────────────────────────────────────────────────────────────┐
│            Purge는 "TRX_ID 기준"으로 일괄 판단                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  가장 오래된 Read View: TRX_ID 100 시점에 생성                   │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Undo Log (TRX_ID=50)  → ✅ Purge 가능 (50 < 100)              │
│  Undo Log (TRX_ID=80)  → ✅ Purge 가능 (80 < 100)              │
│  ─────────────── Purge 기준점 (TRX_ID 100) ───────────────      │
│  Undo Log (TRX_ID=150) → ❌ Purge 불가 (150 >= 100)            │
│  Undo Log (TRX_ID=200) → ❌ Purge 불가 (200 >= 100)            │
│  Undo Log (TRX_ID=999) → ❌ Purge 불가 (999 >= 100)            │
│                                                                 │
│  → 어떤 테이블, 어떤 row인지 상관없이 TRX_ID만 보고 판단          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**4.3.3 Long Transaction이 전체 시스템에 영향을 주는 이유**

```
┌─────────────────────────────────────────────────────────────────┐
│           Long Tx 하나가 전체 시스템의 Purge를 막는 원리           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Long Tx (TRX_ID=100)가 2달간 Read View 유지                     │
│                                                                 │
│  → 가장 오래된 Read View = TRX_ID 100 시점                       │
│  → Purge 기준점 = 100                                           │
│  → TRX_ID >= 100인 모든 Undo Log 삭제 불가                       │
│                                                                 │
│  2달간 발생한 모든 트랜잭션 (시스템 전체):                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  users 테이블:    UPDATE 50만 건  → Undo 50만 개         │    │
│  │  orders 테이블:   UPDATE 30만 건  → Undo 30만 개         │    │
│  │  products 테이블: UPDATE 10만 건  → Undo 10만 개         │    │
│  │  payments 테이블: UPDATE 20만 건  → Undo 20만 개         │    │
│  │  ... (모든 테이블의 모든 UPDATE/DELETE)                  │    │
│  │                                                         │    │
│  │  TRX_ID: 101, 102, 103, ... 999999                      │    │
│  │  전부 TRX_ID >= 100 이므로 Purge 불가!                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  결과:                                                           │
│  → HLL = 2달간 발생한 모든 UPDATE/DELETE 건수                    │
│  → 수백만 ~ 수천만 도달                                          │
│  → Undo Tablespace 폭증 → Storage Full                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**4.3.4 공식 문서 참고**

https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html

> "Update undo logs are used also in consistent reads, but they can be discarded **only after there is no transaction present** for which InnoDB has assigned a snapshot that in a consistent read could require the information in the update undo log to build an earlier version of a database row."

**핵심**: InnoDB는 "가장 오래된 활성 트랜잭션의 스냅샷"을 추적하여 Purge 가능 여부를 판단한다.

**4.3.5 Purge 차단 원인 확인 쿼리**

```sql
-- 가장 오래된 트랜잭션 확인 (= Purge 차단 원인)
SELECT
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(MINUTE, trx_started, NOW()) AS running_minutes,
    trx_query
FROM information_schema.INNODB_TRX
ORDER BY trx_started ASC
LIMIT 1;

-- 이 트랜잭션이 끝나야 그 이후의 모든 Undo Log가 Purge 가능해짐
```

### 4.4 Read View 생성 시점 (Isolation Level별)

Read View는 Transaction의 **Isolation Level에 따라 다른 시점에 생성**된다.

```
┌─────────────────────────────────────────────────────────────────┐
│                Isolation Level별 Read View 생성 시점              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REPEATABLE READ (MySQL InnoDB 기본값)                           │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│    BEGIN;                      ← 트랜잭션 시작 (Read View 없음)   │
│    SELECT * FROM users;        ← 첫 번째 SELECT에서 생성!        │
│    SELECT * FROM orders;       ← 기존 Read View 재사용           │
│    SELECT * FROM users;        ← 기존 Read View 재사용           │
│    COMMIT;                     ← Read View 해제                 │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  READ COMMITTED                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│    BEGIN;                      ← 트랜잭션 시작                   │
│    SELECT * FROM users;        ← Read View 생성 → 사용 → 해제    │
│    SELECT * FROM orders;       ← Read View 생성 → 사용 → 해제    │
│    SELECT * FROM users;        ← Read View 생성 → 사용 → 해제    │
│    COMMIT;                                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

| Isolation Level | Read View 생성 시점 | Read View 해제 시점 |
| --- | --- | --- |
| `REPETABLE READ`  | 첫 번째 SELECT 실행 시 | COMMIT/ROLLBACK 시 |
| `READ COMMITED`  | 매 SELECT 실행 시 | 해당 SELECT 완료 시 |

### 4.4 Read View 내부 구조

Read View는 "어떤 트랜잭션의 변경사항이 보이는가"를 판단하기 위한 정보를 담고있다

```
┌─────────────────────────────────────────────────────────────────┐
│                     Read View 구조                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Read View 생성 시점: T=0, 현재 활성 트랜잭션: [100, 105, 110]     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  m_creator_trx_id = 100    ← 이 Read View를 만든 Trx      │    │
│  │  m_low_limit_id = 111      ← 이 ID 이상은 무조건 안 보임   │    │
│  │  m_up_limit_id = 100       ← 이 ID 미만은 무조건 보임      │    │
│  │  m_ids = [100, 105, 110]   ← 생성 시점에 활성 상태인 Trx들 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  가시성 판단 로직:                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  if (trx_id < m_up_limit_id)                            │    │
│  │      → 보임 (이미 커밋된 오래된 트랜잭션)                   │    │
│  │                                                         │    │
│  │  if (trx_id >= m_low_limit_id)                          │    │
│  │      → 안 보임 (Read View 생성 후에 시작된 트랜잭션)        │    │
│  │                                                         │    │
│  │  if (trx_id in m_ids)                                   │    │
│  │      → 안 보임 (생성 시점에 아직 커밋 안 된 트랜잭션)        │    │
│  │                                                         │    │
│  │  else                                                   │    │
│  │      → 보임 (m_up ~ m_low 사이에서 이미 커밋된 트랜잭션)    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.5 Undo Log 삭제 조건 상세

Undo Log는 종류에 따라 삭제 시점이 다르다.

```
┌─────────────────────────────────────────────────────────────────┐
│                   Undo Log 종류별 삭제 시점                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. INSERT Undo Log                                             │
│     ─────────────────────────────────────────────────────────   │
│     → 트랜잭션 COMMIT 즉시 삭제 가능                              │
│     → 이유: 다른 트랜잭션이 "INSERT 이전 상태"를 볼 필요 없음       │
│            (INSERT 전에는 그 행 자체가 없었으므로)                 │
│                                                                 │
│  2. UPDATE/DELETE Undo Log                                      │
│     ─────────────────────────────────────────────────────────   │
│     → 아래 조건 모두 만족 시 삭제:                                 │
│                                                                 │
│     ┌───────────────────────────────────────────────────────┐   │
│     │ 조건 1: 해당 트랜잭션이 COMMIT 됨                        │   │
│     │ 조건 2: 해당 Undo Log를 필요로 하는 Read View가 없음     │   │
│     └───────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.6 Purge Thread 동작 방식

```
┌─────────────────────────────────────────────────────────────────┐
│                    Purge Thread 동작 방식                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  시스템에 존재하는 Read View들:                                   │
│                                                                 │
│  Read View A (Trx 100, T=0에 생성)  ← 가장 오래됨                │
│  Read View B (Trx 500, T=5에 생성)                              │
│  Read View C (Trx 800, T=8에 생성)  ← 가장 최신                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Purge Thread 판단:                                              │
│  "가장 오래된 Read View(A)보다 이전에 커밋된 트랜잭션의            │
│   Undo Log만 삭제할 수 있어"                                     │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │   Trx 50 (T=-2 커밋)  → ✅ Purge 가능                   │    │
│  │   Trx 80 (T=-1 커밋)  → ✅ Purge 가능                   │    │
│  │   ─────────── Read View A 생성 (T=0) ───────────        │    │
│  │   Trx 200 (T=1 커밋)  → ❌ Purge 불가 (A가 필요할 수도)  │    │
│  │   Trx 300 (T=2 커밋)  → ❌ Purge 불가                   │    │
│  │   ─────────── Read View B 생성 (T=5) ───────────        │    │
│  │   Trx 600 (T=6 커밋)  → ❌ Purge 불가                   │    │
│  │                                                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ※ Read View A가 종료되면?                                       │
│     → Trx 200, 300의 Undo Log도 Purge 가능해짐                   │
│     → 하지만 Read View B 이후 것들은 여전히 B 기준으로 판단        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.7 History List Length (HLL)

**HLL: Purge 대기 중인 Undo Log 페이지 수**

```sql
-- HLL 확인 방법
SHOW ENGINE INNODB STATUS;

-- 출력 예시:
-- ------------
-- TRANSACTIONS
-- ------------
-- Trx id counter 12345678
-- Purge done for trx's n:o < 12345600 undo n:o < 0 state: running
-- History list length 1523456  ← 이 값이 HLL
```

### 4.8 Purge 지연 시 발생하는 현상

```
┌─────────────────────────────────────────────────────────────────┐
│                  Purge 지연의 연쇄 효과                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Long Transaction 시작                                          │
│          │                                                      │
│          ▼                                                      │
│   Read View 유지 (오래된 스냅샷 필요)                                 │
│          │                                                      │
│          ▼                                                      │
│   Purge Thread가 Undo Log 삭제 불가                                │
│          │                                                      │
│          ▼                                                      │
│   Undo Log 계속 누적                                              │
│          │                                                      │
│          ▼                                                      │
│   HLL (History List Length) 증가                                 │
│          │                                                      │
│          ▼                                                      │
│   Undo Tablespace 크기 증가                                       │
│          │                                                      │
│          ▼                                                      │
│   Disk Storage 소진                                              │
│          │                                                      │
│          ▼                                                      │
│   ❌ Storage Full 장애                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 이번 장애 발생 메커니즘

### 5.1 장애 시나리오 재구성

```
┌─────────────────────────────────────────────────────────────────┐
│                      장애 발생 과정                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [Day 1] Redash에서 adhoc 쿼리 실행                              │
│          │                                                      │
│          │  SELECT p.id AS product_id,                          │
│          │         b.name AS brand_name,                        │
│          │         ...                                          │
│          │  FROM products p                                     │
│          │  LEFT JOIN brands b ...                        │
│          │                                                      │
│          ▼                                                      │
│  [Day 1] 쿼리 실행 중 브라우저 닫기 or 네트워크 끊김               │
│          │                                                      │
│          │  - Redash 세션은 끊어졌지만                            │
│          │  - MySQL 트랜잭션은 종료되지 않음                       │
│          │  - Read View 계속 유지                                │
│          │                                                      │
│          ▼                                                      │
│  [Day 1~60] 다른 트랜잭션들의 변경사항 누적                        │
│          │                                                      │
│          │  - 정상적인 INSERT/UPDATE/DELETE 발생                 │
│          │  - 각각 Undo Log 생성                                 │
│          │  - 하지만 Long Tx가 Read View를 들고 있어서            │
│          │    Purge 불가                                         │
│          │                                                      │
│          ▼                                                      │
│  [Day 60] HLL = 수백만, Undo Tablespace 폭증                    │
│          │                                                      │
│          ▼                                                      │
│  [Day 60] Storage Full → DB 장애                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 왜 Replica가 Primary보다 빨리 Storage가 찼는가?

```
┌─────────────────────────────────────────────────────────────────┐
│              Primary vs Replica Storage 소진 비교                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [가설 1] Long Transaction이 Replica에서 실행됨                   │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                   │
│  │   Primary   │    Binlog    │   Replica   │                   │
│  │             │ ──────────►  │             │                   │
│  │  정상 동작   │    복제      │  Long Tx    │                   │
│  │             │              │  실행 중     │                   │
│  └─────────────┘              └─────────────┘                   │
│        │                            │                           │
│        ▼                            ▼                           │
│   Purge 정상 동작              Purge 지연 발생                    │
│   HLL 낮음                     HLL 폭증                          │
│   Storage 안정                 Storage 빠르게 소진                │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [가설 2] Replica의 추가 부담                                     │
│                                                                 │
│  Replica는 다음을 동시에 처리:                                    │
│  1. Primary로부터 받은 Binlog 적용 (Undo Log 생성)                │
│  2. 자체 Read 쿼리 처리 (Read View 유지)                          │
│  3. Long Transaction으로 인한 Purge 지연                         │
│                                                                 │
│  → 이중/삼중 부담으로 Storage 더 빠르게 소진                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 AAS 0.99의 의미

해당 쿼리가 측정 기간 동안 거의 항상 1개 세션을 점유하고 있었음

= 쿼리가 종료되지 않고 계속 실행중이었다는 증거

---

## 6. 재발 방지 대책

### 6.1 Slack Alert 추가

- HLL 길이 제한
    - (오래된 트랜잭션 때문에 Undo Log가 쌓이는 것을 알 수 있던 지표)
    - 50,000 주의
        - Long Transaction 존재 가능성
    - 100,000 위험
        - 즉시 조사 필요
        - Storage 고갈 위험
        - Select 성능 저하 발생
- Free Storage Space < 20GB
    - (Undo Log가 쌓인다는 것을 Storage 고갈로 알 수 있었음.)
- CPUUtilization 80% 지속

### 6.2 Replica 계정 분리

현재는 단일 계정으로 사용중, 목적에 따라 계정을 분리한다.

- Application Server: 현재 계정 사용
- Redash: BI 도구용 계정
- Data Analysis: 데이터 분석 목적 계정

### 6.3 Redash Timeout 설정

https://redash.io/help/open-source/admin-guide/env-vars-settings/

> Many aspects of the functionality of Redash can be changed with settings. Settings are read by `redash.settings` from environment variables which (for most installs) can be set in `/opt/redash/.env`. When developing with Docker, create the `.env` file in the root directory.

```yaml
# Redash 환경변수
REDASH_ADHOC_QUERY_TIME_LIMIT: 10800  # 3시간
REDASH_SCHEDULED_QUERY_TIME_LIMIT: 10800 # 3시간
```

### 6.4 MySQL Timeout 적용

- 현재 설정

    ```sql
    -- 모든 관련 설정 한번에 확인
    SHOW VARIABLES WHERE Variable_name IN (
    'max_execution_time',
    'wait_timeout',
    'interactive_timeout',
    'innodb_lock_wait_timeout',
    'innodb_rollback_on_timeout',
    'net_read_timeout',
    'net_write_timeout'
    );
    ```

    ![MySQL Timeout 설정](/images/mysql-long-transaction/image%204.png)

    - max_execution_time 제한 추가 (24시간)

---

## 7. 늘어난 Undo Log storage 처리

### 7.1 현재 상태

아래 차이 때문에 primary DB 660에 replica DB 730인데도 replica의 free storage space가 더 적음

```sql
SHOW VARIABLES LIKE 'innodb_undo_log_truncate';  -- 현재: ON (8.0.2+)
SHOW VARIABLES LIKE 'innodb_max_undo_log_size';  -- 현재: 1G
SHOW VARIABLES LIKE 'innodb_purge_rseg_truncate_frequency'; -- 현재: 128

SELECT
    NAME,
    STATE,
    FILE_SIZE / 1024 / 1024 / 1024 AS 'Physical_Size_GB',     -- OS가 인식하는 실제 파일 크기
    ALLOCATED_SIZE / 1024 / 1024 / 1024 AS 'Logical_Size_GB' -- 실제 데이터가 들어있는 크기
FROM information_schema.innodb_tablespaces
WHERE NAME LIKE '%undo%';
```

![Undo Tablespace 상태](/images/mysql-long-transaction/image%205.png)

### 7.2 MySQL 8.0+ Truncate 실행 조건

- 조건:
    - innodb_undo_log_truncate: ON
    - innodb_max_undo_log_size: 1GB
    - Undo Tablespace 상태 `inactive`
- 필요하면 수동으로 undo_001을 제거해주거나 강제로 Truncate를 수행하도록 해야함

---

### 참고 문서

- https://leezzangmin.tistory.com/55
- https://aws.amazon.com/ko/blogs/tech/achieve-a-high-speed-innodb-purge-on-amazon-rds-for-mysql-and-amazon-aurora-mysql/
- https://medium.com/@anujkirodia/understanding-transactions-hll-history-list-length-isolation-levels-in-rds-relational-8429efb2510a
- https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html
- https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html
- https://dev.mysql.com/doc/refman/8.0/en/innodb-purge-configuration.html
- https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html#innodb--undo-tablespace-size
- https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html
